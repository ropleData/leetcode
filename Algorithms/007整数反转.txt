题目：
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。


############################################################
思路:
第一步：分析题目，首先是让反转一个有符号的整数，同时要考虑到反转后是否会溢出;
第二步：和反转字符串类似，首先会想到python里面已经有的反转方法[::-1]，哈哈，不过这里当然不能这样去设计;
第三步：整数反转的话，我们可以借助数学方法：通过10 /取整, %取余；
第四步：结合溢出条件加以判断，循环输出即可。


############################################################
结论：
1、总体思路是在循环中对该有符号整数和10取整，然后得出的值作为下一次循环的值，取余的值进行*10，循环操作，随着后面不断地循环累计那么第一次取余的数就会成为第一位数字了；
	//获取数字
	pop = x % 10;
	x /= 10;

	//重新组合
	temp = rev * 10 + pop;
	rev = temp;
2、由于题目要求环境只能存储32位的有符号整数，因此temp = rev * 10 + pop这个地方要去考虑会不会越界溢出；
	2.1、假设rev是正数，那么当rev>(int32最大值)/10,就一定会溢出了；
	2.2、由于32位最大可以赋值为：2147483647，所以当那么当rev==(int32最大值)时，pop如果大于7，就会溢出。

注意：
在Python中，取余的计算公式与别的语言并没有什么区别：r=a-n*[a//n]
这里r是余数，a是被除数，n是除数。
不过在“a//n”这一步，当a是负数的时候，我们上面说了，会向下取整，也就是说向负无穷方向取整。这也就得到：
	-123%10 = -123 - 10 * (-123 // 10) = -123 - 10 * (-13) = 7
所以负数取余要%-10

复杂度：
时间复杂度：O(log(x))，x中大约有log10(x)位数字。
空间复杂度：O(1)。
############################################################
附上java,python3，c的实现代码：

class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
}
python3：
class Solution:
    def reverse(self, x: int) -> int:
        rev =0
        minval = -2**31
        maxval = 2**31-1
        
        while x!=0:
            if x>0:
                pop = x%10
            if x<0:
                pop = x%-10
            x /= 10
            x =int(x)     
            if rev > (maxval/10) or (rev == (maxval / 10) and  pop > 7):
                return 0
            if rev < (minval/10) or (rev == (minval / 10) and pop < -8):
                return 0
            rev = rev * 10 + pop
        return rev


C：
int reverse(int x)
{
    int max = 0x7fffffff, min = 0x80000000;//int的最大值最小值
    long rs = 0;//用long类型判断溢出
    for(;x;rs = rs*10+x%10,x/=10);//逆序，正负通吃，不用单独考虑负值
    return rs>max||rs<min?0:rs;//超了最大值低于最小值就返回0
}






