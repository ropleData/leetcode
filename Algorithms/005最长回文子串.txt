题目：
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"


############################################################
思路:
第一步：分析题目，给定字符串，要求出最长的回文子串，回文子串就代表该子串正反一致;
第二步：首先想到的是暴力破解法，就是求出所有的回文子串，然后选出最长的子串，但是由于验证每个字符串需要N,然后一共有n*(n-1)/2个子串，所以时间复杂度过高O(n^3) 三次方;
第三步：通过学习发现本题的解法有很多（最长公共子串，暴力法，动态规划，中心扩展算法，Manacher 算法）；
第四步：这里我选择暴力法，最长公共子串，Manacher 算法（马拉车算法）来解决。


############################################################
结论：
暴力法的逻辑比较简单，时间复杂度O(n^3),空间复杂度O(1);
最长公共子串主要逻辑是根据回文子串的特性，将源字符串反转，然后寻找两个字符串的最长公共子串，不过要注意避免原字符串中非回文子串的反向副本在反转后造成的舞蹈，例如（S=“abacdfgdcaba”, S' = “abacdgfdcaba”之间的最长公共子串为 “abacd”。但是这不是回文子串），因此我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配（只需要判断末尾字符就可以了），时间复杂度O(n^2),空间复杂度O(n^2),我们可以对空间复杂度进行优化，优化后的空间复杂度O(n);

Manacher's Algorithm 马拉车算法：



复杂度：
假设第一个数组长度为m，第二个数组长度为n
时间复杂度：O(log（min（m，n））
空间复杂度：O(1)
############################################################
附上java,python3的实现代码：

暴力法：
java：
public boolean isPalindromic(String s) {
		int len = s.length();
		for (int i = 0; i < len / 2; i++) {
			if (s.charAt(i) != s.charAt(len - i - 1)) {
				return false;
			}
		}
		return true;
	}
public String longestPalindrome(String s) {
    String ans = "";
    int max = 0;
    int len = s.length();
    for (int i = 0; i < len; i++)
        for (int j = i + 1; j <= len; j++) {
            String test = s.substring(i, j);
            if (isPalindromic(test) && test.length() > max) {
                ans = s.substring(i, j);
                max = Math.max(max, ans.length());
            }
        }
    return ans;
}

最长公共子串：
public String longestPalindrome(String s) {
    if (s.equals(""))
        return "";
    String origin = s;
    String reverse = new StringBuffer(s).reverse().toString();
    int length = s.length();
    int[][] arr = new int[length][length];
    int maxLen = 0;
    int maxEnd = 0;
    for (int i = 0; i < length; i++)
        for (int j = 0; j < length; j++) {
            if (origin.charAt(i) == reverse.charAt(j)) {
                if (i == 0 || j == 0) {
                    arr[i][j] = 1;
                } else {
                    arr[i][j] = arr[i - 1][j - 1] + 1;
                }
            }
            if (arr[i][j] > maxLen) {
                int beforeRev = length - 1 - j;
                if (beforeRev + arr[i][j] - 1 == i) { //判断下标是否对应
                    maxLen = arr[i][j];
                    maxEnd = i;
                }
            }
        }
    return s.substring(maxEnd - maxLen + 1, maxEnd + 1);
}

优化后的最长公共子串：
public String longestPalindrome(String s) {
    if (s.equals(""))
        return "";
    String origin = s;
    String reverse = new StringBuffer(s).reverse().toString();
    int length = s.length();
    int[] arr = new int[length];
    int maxLen = 0;
    int maxEnd = 0;
    for (int i = 0; i < length; i++)
        /**************修改的地方***************************/
        for (int j = length - 1; j >= 0; j--) {
        /**************************************************/
            if (origin.charAt(i) == reverse.charAt(j)) {
                if (i == 0 || j == 0) {
                    arr[j] = 1;
                } else {
                    arr[j] = arr[j - 1] + 1;
                }
            /**************修改的地方***************************/
            //之前二维数组，每次用的是不同的列，所以不用置 0 。
            } else {
                arr[j] = 0;
            }
            /**************************************************/
            if (arr[j] > maxLen) {
                int beforeRev = length - 1 - j;
                if (beforeRev + arr[j] - 1 == i) {
                    maxLen = arr[j];
                    maxEnd = i;
                }

            }
        }
    return s.substring(maxEnd - maxLen + 1, maxEnd + 1);
}

Manacher's Algorithm 马拉车算法:
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        n = len(nums1)
        m = len(nums2)

        if n > m:
            return self.findMedianSortedArrays(nums2, nums1)

        start_pos = 0
        end_pos = 2 * n

        while start_pos <= end_pos:
            c1 = (start_pos + end_pos) // 2
            c2 = m + n - c1  ##因为数组从0开始，所以c1+c2=(m+n+1)-1

            LMax1 = nums1[(c1 - 1) // 2] if c1 > 0 else (-1 * sys.maxsize)
            RMin1 = nums1[c1 // 2] if c1 < 2 * n else sys.maxsize
            LMax2 = nums2[(c2 - 1) // 2] if c2 > 0 else (-1 * sys.maxsize)
            RMin2 = nums2[c2 // 2] if c2 < 2 * m else sys.maxsize

            if LMax1 > RMin2:
                end_pos = c1 - 1
            elif LMax2 > RMin1:
                start_pos = c1 + 1
            else:
                break

        return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0
		
C:		
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}




